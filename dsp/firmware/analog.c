/*
    bluxboxes dsp - Copyright (c) 2016-2020 David Turner
    Uses ChibiOS RT/HAL - Copyright (C) 2006..2016 Giovanni Di Sirio
    Based on M2FC analogue driver, (c) 2015 Eivind Roson Eide, CUSF

    blueboxes dsp is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.

    blueboxes dsp is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <ch.h>
#include <chbsem.h>
#include <hal.h>

#include "analog.h"

#define INST_BUF_DEPTH 100

/****************** Callback Declarations ******************************/
static void dac_end_callback(DACDriver*, const dacsample_t*, size_t);
static void dac_error_callback(DACDriver*, dacerror_t);

/****************** Sample Buffers *************************************/
// Generated by gen_sin.py
static volatile uint16_t inst_buffer[INST_BUF_DEPTH] = {
    2047, 2176, 2304, 2431, 2556, 2680, 2801, 2919, 3033, 3144, 3250, 3352,
    3449, 3540, 3625, 3703, 3776, 3841, 3900, 3951, 3994, 4030, 4058, 4078,
    4090, 4095, 4090, 4078, 4058, 4030, 3994, 3951, 3900, 3841, 3776, 3703,
    3625, 3540, 3449, 3352, 3250, 3144, 3033, 2919, 2801, 2680, 2556, 2431,
    2304, 2176, 2047, 1918, 1790, 1663, 1538, 1414, 1293, 1175, 1061, 950, 844,
    742, 645, 554, 469, 391, 318, 253, 194, 143, 100, 64, 36, 16, 4, 0, 4, 16,
    36, 64, 100, 143, 194, 253, 318, 391, 469, 554, 645, 742, 844, 950, 1061,
    1175, 1293, 1414, 1538, 1663, 1790, 1918};

/****************** Configuration Structures ***************************/
/* Timer used to trigger inst ADC captures */
static const GPTConfig gpt_inst_config =
{
     43750,             // clock: 44kHz-ish
     NULL,              // callback function (not used)
     0,                 // CR2
     0                  // DIER
};

/* DAC config for DAC1 */
static const DACConfig dac_cfg = {
    .init     = 0,
    .datamode = DAC_DHRM_12BIT_RIGHT,
};

/* DAC output conversion group */
static const DACConversionGroup dac_conv_grp = {
    .num_channels = 1U,
    .end_cb       = dac_end_callback,
    .error_cb     = dac_error_callback,
    .trigger      = DAC_TRG(1), // Trigger off TIM8 TRGO
};

/****************** Callback Definitions *******************************/
/* Called at end of DAC buffer conversion */
static void dac_end_callback(DACDriver *dacp, const dacsample_t *buf, size_t n)
{
    (void)dacp;
    (void)buf;
    (void)n;
}

/* Called upon DAC error */
static void dac_error_callback(DACDriver* dacp, dacerror_t err)
{
    (void)dacp;
    (void)err;
    chSysHalt("Panic: DAC Error.");
    while(1);
}

/****************** Thread main loop ***********************************/
msg_t analog_thread(void *args)
{
    (void)args;

    chRegSetThreadName("Analog");

    dacInit();
    dacStart(&DACD1, &dac_cfg);
    dacStartConversion(&DACD1, &dac_conv_grp, (dacsample_t*)inst_buffer,
                       INST_BUF_DEPTH);
    // Enable DAC output buffer:
    DACD1.params->dac->CR |= DAC_CR_BOFF1;

    /* Start the GPT timers. They reload at after reaching 1 such that
     * TRGO frequency equals timer frequency. */
    gptStart(&GPTD8, &gpt_inst_config);
    GPTD8.tim->CR2 |= STM32_TIM_CR2_MMS(2);
    gptStartContinuous(&GPTD8, 2);
    GPTD8.tim->DIER &= ~STM32_TIM_DIER_UIE;

    while(true) {
        chThdSleepMilliseconds(1000);
    }
}
